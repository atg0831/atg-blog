---
layout: post
title: ğŸ“BOJ-15650 Nê³¼ M(2)
subtitle: 
comments: true
tags: [algorithm,brute-force]
---

## ë¬¸ì œ
BOJ 15650ë²ˆ : [Nê³¼ M(2)](https://www.acmicpc.net/problem/15650)  
## ì ‘ê·¼ ë°©ë²•

**í’€ì´ ê³¼ì •ì„ ì‘ì„±í•©ì‹œë‹¤...**    
**ì´í•˜ë™ë¬¸....**

- **í’€ì´**  
  **- itertoolsì˜ combinationsë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ.**  
  **- ì§ì ‘ recursiveí•˜ê²Œ combinationì„ êµ¬í˜„í–ˆë‹¤.**  
  
<details>
<summary>source code</summary>
<div markdown="1">

```python
# just use list to create recursive combination function
def solution_1(N, M):
    inputList = [i for i in range(0, N+1)]
    selected = [False]*(N+1)

    def Combinations(start, cnt):
        if cnt == M:
            for i in range(1, N+1):
                if selected[i] == True:
                    print(inputList[i], end=' ')
            print()
            return
        for i in range(start, N+1):
            if selected[i] == True:
                continue

            selected[i] = True
            Combinations(i+1, cnt+1)
            selected[i] = False

    Combinations(1, 0)

# use stack to create recursive combination function(list.append()...)
def solution_2(N, M):
    inputList = [i for i in range(0, N+1)]
    selected = []

    def Combinations(start, cnt):
        # if len(selected)==M
        if cnt == M:
            for element in selected:
                print(element, end=' ')
            print()
            return
        for i in range(start, N+1):
            selected.append(inputList[i])
            # Plus one with last in element of selected
            # due to choose next element when Combinations called
            start = selected[-1]+1
            Combinations(start, cnt+1)
            selected.pop()

    Combinations(1, 0)

# not using iterative, but only recursive
def solution_3(N, M):
    inputList = [i for i in range(0, N+1)]
    selected = []

    def combinations(start):
        if len(selected) == M:
            for element in selected:
                print(element, end=' ')
            print()
            return

        # ë” ì´ìƒ ë½‘ì„ ì¡°í•©ì´ ì—†ë‹¤ ì˜ëª»ëœ ì¡°í•©ì„ ì¶”ì¶œí•˜ê³  ìˆì—ˆìœ¼ë‹ˆ return
        if start >= N+1:
            return

        # ì´ë²ˆ index ì›ì†Œ ë½‘ëŠ” ê²½ìš°
        selected.append(inputList[start])
        combinations(start+1)

        # ì´ë²ˆ indexì˜ ê°’ì„ selectedì—ì„œ ë¹¼ê³  index+1ë¡œ ì¬ê·€ call...
        selected.pop()
        combinations(start+1)

    combinations(1)

if __name__ == "__main__":
    N, M = map(int, input().split())
    solution_1(N, M)
    print(2)
    solution_2(N, M)
    print(3)
    solution_3(N, M)

```
<br>


</div>
</details>


<!-- {% include algorithm-solution.md %} -->
<!-- {% include BOJ-2309.md %} -->

{: .box-note}
**ì½”ë“œ ì„¤ëª…**   ì´ 3ê°€ì§€ë¡œ ì¡°ê¸ˆì”© ë‹¤ë¥´ê²Œ êµ¬í˜„í•˜ì˜€ìœ¼ë©° ìˆœì—´ì¡°í•© ê³µë¶€ë¥¼ ìœ„í•œ ë¬¸ì œí’€ì´ ì˜€ë‹¤. 
